# 96. 不同的二叉搜索树  

[力扣题目链接](https://leetcode-cn.com/problems/unique-binary-search-trees/)  

给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

示例 1：
````
输入：n = 3
输出：5
````

示例 2：
````
输入：n = 1
输出：1
````

提示：
- 1 <= n <= 19

## 思路
n 个节点的BST颗数应该是下面各式的和：  
- root=1, 0 个节点构成的左子树的个数 * n-1 个节点构成的右子树的个数
- root=2, 1 个节点构成的左子树的个数 * n-2 个节点构成的右子树的个数
- root=3, 2 个节点构成的左子树的个数 * n-3 个节点构成的右子树的个数
- ...
- root=n-1, n-2 个节点构成的左子树的个数 * 1 个节点构成的右子树的个数
- root=n, n-1 个节点构成的左子树的个数 * 0 个节点构成的右子树的个数

所以有  
> **f(n) = f(0) * f(n-1) + f(1) * f(n-2) + ... + f(n-1) * f(0)**  

注：这个题开始想叉了，列出了从 n=1 到 n=5 的所有的BST，试图找到他们之间的数量关系。
消耗了1个多小时，也没有成功。后面还是从题意出发，直接分析 n 个节点的BST的数量，结果
发现这个递推公式是相当的直接啊。  

因为BST是递归定义的，所以，如果构成左子树的 k 个节点
能够构成 m 棵BST，构成右子树的 n-k-1 个节点能够构成 n 棵BST，那么，以 k 为根节点
且共有 n 个节点能够构成的BST数量就为 m*n 。

***动态规划五步：***  
1. DP数组及下标的含义  
   dp[i]表示共 i 个节点所能构成的BST的数量
2. 递推公式  
   f(n) = f(0) * f(n-1) + f(1) * f(n-2) + ... + f(n-1) * f(0)
3. DP数组的初始化
   dp[0] = 1, 只是方便计算，并无实际意义
   dp[1] = 1, 1个节点可以构成1颗BST
4. 确定遍历顺序  
   从前往后计算
5. 举例推导DP数组  
   以 n = 4 为例说明：
   dp[0] = 1  
   dp[1] = 1  
   dp[2] = dp[0]*dp[1] + dp[1]*dp[0] = 2  
   dp[3] = dp[0]*dp[2] + dp[1]*dp[1] + dp[2]*dp[0] = 5
   dp[4] = dp[0]*dp[3] + dp[1]*dp[2] + dp[2]*dp[1] + dp[3]*dp[0] = 14
   
### 代码

````Go
func numTrees(n int) int {
	if n <= 2 {return n}
	
	dp := make([]int, n+1)
	dp[0] = 1
	dp[1] = 1
	dp[2] = 2
	
	for i := 3; i <= n; i++ {
		tmp := 0
		for j := 0; j < i; j++ {
			tmp += dp[j] * dp[i - j - 1]
		}
		dp[i] = tmp
	}
	
	return dp[n]
}
````

**复杂度分析**
- 时间复杂度：O(n^2)，因为对于每个n，都需要从1开始、一直计算到n-1为止
- 空间复杂度：O(n)
