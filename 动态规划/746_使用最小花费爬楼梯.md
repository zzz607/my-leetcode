# 746. 使用最小花费爬楼梯  

[力扣题目链接](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)  

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦
你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

示例 1：
````
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
  总花费为 15 。
````

 示例 2：
````
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
  总花费为 6 。
````

提示：

- 2 <= cost.length <= 1000
- 0 <= cost[i] <= 999

## 思路
假设现在只有3级台阶，那么，要到达第3阶，有哪些路径呢？  

1. 从第 2 级台阶跨 1 个台阶可达，费用为cost[2]
2. 从第 1 级台阶跨 2 台阶可达，费用为cost[1]

所以，到达第 3 级台阶最小花费就是：min(accu[2] + cost[2], accu[1] + cost[1])，
其中accu[i]表示到达第i级台阶的累计花费。  

将accu用函数f来表示，表达即为:  

>***f[3] = min(f[2] + cost[2], f[1] + cost[1])***  

一般化即为：  

>***f(n) = min(f[n-1] + cost[n-1], f[n-2] + cost[n-2])***

还是和斐波那契公式很像

**动态规划五步：**  
1. DP数组及下标的含义  
   dp[i]表示f(i)，即到达第i级台阶的最低花费
2. 递推公式  
   f(n) = min(f[n-1] + cost[n-1], f[n-2] + cost[n-2])  
   由于只依赖前面二项，因此，可以使用滚动数组的优化小技巧，即可以只保留前面二项的结果
3. DP数组的初始化  
   F(0) = 0，F(1) = 0  
   即第 0 级台阶或者第 1 级台阶不需要爬
4. 确定遍历顺序  
   由递推公司可知，第n项的计算依赖前面二项，因此，需要从前往后计算
5. 举例推导DP数组  
   对于示例数据***cost = [10,15,20]***，dp数组应该是如下的数列：  
   0 0 10 15
   
### 代码

````
func minCostClimbingStairs(cost []int) int {
    var pp, p = 0, 0
    for i := 2; i <= len(cost); i++ {
        pp, p = p, int(math.Min(float64(pp + cost[i - 2]), float64(p + cost[i - 1])))
    }
    return p
}
````

**复杂度分析**
- 时间复杂度：O(N)
- 空间复杂度：O(1)
