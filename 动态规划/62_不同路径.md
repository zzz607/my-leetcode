# 62. 不同路径  

[力扣题目链接](https://leetcode-cn.com/problems/unique-paths/)  

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

问总共有多少条不同的路径？

|start|   |   |   |   |   |   |
|---|---|---|---|---|---|---|
|   |   |   |   |   |   |    |
|   |   |   |   |   |   | ***finish***  |

示例 1：
````
输入：m = 3, n = 7
输出：28
````

示例 2：
````
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
````
   
示例 3：
````
输入：m = 7, n = 3
输出：28
````

示例 4：
````
输入：m = 3, n = 3
输出：6
````

提示：

- 1 <= m, n <= 100
- 题目数据保证答案小于等于 2 * 109

## 思路
|0      |1      |2      |
|-------|-------|-------|
|***3***|***4***|***5***|
|***6***|***7***|***8***|

要到达右下角的 8 号位置，有哪些路径呢？  

1. 从 5 号位置向下走一步
2. 从 7 号位置向右走一步  

所以，到达第 8 号位置的路径方法数等于到达第 5 号位置的路径方法数加上到达第 7 号位置的路径
方法数， 用数学表达式来表达即为:  

>**f(8) = f(5) + f(7)**  

换成坐标即为：  

>**f(m, n) = f(m - 1, n) + f(m, n - 1)**

可以继续往下推导：   

>**f(m - 1, n) = f(m - 2, n) + f(m - 1, n - 1)**  
>**f(m, n - 1) = f(m - 1, n - 1) + f(m, n - 2)**  

仅仅二步推导，就可以发现重叠子问题 **f(m - 1, n - 1)**，所以，可以适用于动态规划

***动态规划五步：***  
1. DP数组及下标的含义  
   dp[i, j] 表示 F(i, j)，即到达坐标为 [i, j] 的方格的路径方法数
2. 递推公式  
   f(m, n) = f(m - 1, n) + f(m, n - 1)
3. DP数组的初始化  
   由于机器人只能向右或者向下，因此，可以得到下面二个初始值：  
   1. 第一行只能向右到达，因此，dp[0][x] 都初始化为 ***1***
   2. 第一列只能向下到达，因此，dp[x][0] 都初始化为 ***1***
4. 确定遍历顺序  
   由递推公式可知，第 [i, j] 个方格在计算时，只依赖于其上边或者左边的数值，而初始
   时第一行和第一列都已经有值了，因此，后续按行计算还是按列计算都是可以的
5. 举例推导DP数组  
   当表格为 3 * 3时，DP取值如下：  
   
   |0      |1      |1      |
   |-------|-------|-------|
   |***1***|***2***|***3***|
   |***1***|***3***|***6***|
   
### 代码

````Go
func uniquePaths(m int, n int) int {
	var i, j int
	dp := make([][]int, m)
	for i = 0; i < m; i++ {
		dp[i] = make([]int, n)
		dp[i][0] = 1
	}
	for i = 0; i < n; i++ {
		dp[0][i] = 1
	}

	for i = 1; i < m; i++ {
		for j = 1; j < n; j++ {
			dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
		}
	}

	return dp[m-1][n-1]
}
````

**复杂度分析**
- 时间复杂度：O(M*N)
- 空间复杂度：O(M*N)  

## 优化

时间复杂度上面并没有太多的优化空间了，但是空间上面还有进一步的优化空间。仔细观察那个递推公式：

>**f(m, n) = f(m - 1, n) + f(m, n - 1)**

可以发现，f(m, n)其实只依赖于它上面的行和它左面的列，因此，利用滚动数组的小技巧，可以将空
间复杂度降低到 ***O(m+n)***

### 代码

````Go
func uniquePaths(m int, n int) int {
	// right保存行方向的值
	right := make([]int, m)
	for i := 0; i < m; i++ {right[i] = 1}
	// down保存下方向的值
	down := make([]int, n)
	for i := 0; i < n; i++ {down[i] = 1}

	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			tmp := right[i] + down[j]
			right[i], down[j] = tmp, tmp
		}
	}

	return right[m - 1]
}
````

经人提醒，right和down二个数组的初始值、更新时间、更新值都一样，可以合并成一个数组。仔细看一下，
确实是这样，不过不在这里改了，留下 不同路径II 里面再改吧
