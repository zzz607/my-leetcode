# 343. 整数拆分  

[力扣题目链接](https://leetcode-cn.com/problems/integer-break/)  

给定一个正整数 n，将其拆分为 k 个正整数的和（k >= 2），并使这些整数的乘积最大化。

返回你可以获得的最大乘积。

示例 1:
````
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
````

示例2:
````
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
````

提示:
- 2 <= n <= 58

## 思路
如果将n拆成 1 和 n-1，则乘积最大值取决于 n-1 拆分后所能获得的最大值。  
如果将n拆成 2 和 n-2，则乘积最大值取决于 2和n-2 分别拆分后所能获得的最大值。  
如果将n拆成 k 和 n-k, 则乘积最大值取决于 k和n-k 分别拆分后所能获得的最大值。  
所以有：f(n) = max(f(1)*f(n-1), f(2)*f(n-2), ..., f(ceil(n/2))*f(floor(n/2)))  

很久之后。。。。。。

上面那个过程有一个可以改进的地方，k其实是不需要拆分的，因为是从 1 到 k 依次
遍历的，所以，k 能够 拆分的数字在前面都已经计算过了。  

除此之外，还有一个错误。将 n 拆分为 k 和 n-k 之后，其乘积最大值并不仅仅取决
k和n-k分别拆分后的最大值，还需要与 k*(n-k) 相比较

综合以上描述，可以得到递推公式：
> **f(n) = max(k * n-k, k * f(n - k)), 1 <= k <= n/2**

***动态规划五步：***  
1. DP数组及下标的含义  
   dp[i]表示数字 i 拆分后所能得到的最大乘积
2. 递推公式  
   f(n) = max(k * n-k, k * f(n - k)), 1 <= k <= n/2
3. DP数组的初始化
   dp[0] = 1, 这个数字没用到
   dp[1] = 1, 按说这个是未定义的，但是设置为1比较方便计算
   dp[2] = 1
4. 确定遍历顺序  
   从前往后计算
5. 举例推导DP数组  
   以 n = 6 为例说明：
   dp[0] = ?  
   dp[1] = 1  
   dp[2] = 1  
   dp[3] = max(1*2, 1*dp[2]) = 2  
   dp[4] = max(max(1*3, 1*f(3)), 
               max(2*2, 2*f(2))) = max(3, 4) = 4  
   dp[5] = max(max(1*4, 1*dp[4]), 
               max(2*3, 2*dp[3])) = max(4, 6) = 6
   dp[6] = max(max(1*5, 1*dp[5],
               max(2*4, 2*dp[4],
               max(3*3, 3*dp[3])))) = max() = 9
   
### 代码

````Go
func integerBreak(n int) int {
	// f(n) = max(k * n-k, k * f(n - k)), 1 <= k <= n/2
	if n <= 2 {return 1}
	dp := [59]int{1,1,1}

	var ret int
	for i := 3; i <= n; i++{
		half := i / 2
		for j := 1; j <= half; j++ {
			anther := i - j
			ret = max(ret, max(j * anther, j * dp[anther]))
		}
		dp[i] = ret
	}

	return ret
}

func max(i, j int) int {
	if i > j {
		return i
	}
	return j
}
````

**复杂度分析**
- 时间复杂度：O(n^2)，因为对于每个n，都需要从1开始、一直计算到n/2为止
- 空间复杂度：O(n)
